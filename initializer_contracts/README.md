# Initializer Contracts

*A new approach to constructors in upgradeable contracts.*


## Motivation

One of the long-standing problems of upgradeability solutions for Ethereum has
been that of constructors. In order to create an upgradeable instance of a
contract `Foo`, we do not really deploy a `Foo` but a `Proxy` which delegates
to a pre-existing deployment of `Foo` on the blockchain; we call this the
proxy's implementation. Because of how contract deployment works, the
implementation contract doesn't have the code for `Foo`'s constructor, and thus
we need to do something special in order to correctly initialize the proxy.

Until now, the workaround for this was to transform the constructor into an
initializer _function_. Such a function would, unlike the constructor, be in
the implementation contract. Thus, the process to create an upgradeable
instance of `Foo` under this model was to first create a `Proxy` instance
pointing to the `Foo` implementation contract, and then call the appropriate
`initialize` function on it, with the desired parameters.

This turns out to be problematic for many reasons.

1) The `initialize` function needs to be protected so that it can only be called
   once. We currently provide modifiers to do this in the `Migratable` contract
   of `zos-lib`, but they need to be manually specified by the developer and
   they are easy to forget.
2) Solidity contracts can inherit from other contracts which may have
   constructors themselves. The compiler can statically check that all the
   necessary constructors are called (and no more than once). If we use
   initializer functions those static checks are lost, and thus part of a
   contract could inadvertently remain uninitialized.
3) In order to be made upgradeable, a contract's source code has to be
   pre-processed so as to convert its constructor into an initializer function.
   This is currently done by a human, but it could be automated, with the usual
   caveats that come with any source code altering tool. Additionally, the
   effort would have to be duplicated for any new high-level contract language.
   

## Solution

The solution we're working on is to put the constructor on-chain, as a separate
contract. We call this "initializer _contracts_", as opposed to initializer
functions.

Creating an upgradeable instance of `Foo`, then, is done by creating an
instance of a `Proxy` with two parameters: the initializer contract and the
implementation contract. The constructor of the proxy will perform a
`delegatecall` to the initializer contract, thus initializing the storage of
the proxy, and will then set its implementation contract.

This model is in fact very similar, conceptually, to how non-upgradeable
contracts are deployed. The constructor and the contract body are very
different things; analogously, the initializer and the implementation are two
very different parameters in the creation of a proxy.

The problems we had identified for initializer functions are now solved.

1) The initializer contract is run only once by design.
2) The compiler statically checks constructors.
3) Any ethereum contract can be made upgradeable without modifying the source
code.


## First proof of concept

```
$ npx buidler run scripts/poc-1.js
```

For this proof of concept we took the bytecode that results from compilation,
a.k.a. the contract creation code, and deployed it, not in the usual way, but
such that the entirety of it is on-chain, and not only the contract body. This
is inefficient because this includes all of the contract body (it's in fact the
return data of the constructor) but we can ignore it.

It's a remaining challenge to make the initializer contract more efficient by
removing the unnecessary contract body. One approach is to syntactically
recognize when the constructor ends in the code generated by Solidity. A more
robust approach we have in mind is to perform a symbolic execution of the
bytecode, from which we can extract: 1) a trace (minus return value) that would
become the initializer contract code, and 2) the return value which would
become the implementation contract code.
